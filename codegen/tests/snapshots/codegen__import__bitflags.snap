---
source: codegen/tests/codegen.rs
expression: bitflags
---
pub mod bitflags {
    #[allow(unused_imports)]
    use wit_bindgen_wasm3::rt::{anyhow, wasm3};
    wit_bindgen_wasm3::rt::bitflags::bitflags! {
      pub struct Properties: u8 {
        const LEGO = 1 << 0;
        const MARVEL_SUPERHERO = 1 << 1;
        const SUPERVILLAN = 1 << 2;
      }
    }

    impl core::fmt::Display for Properties {
        fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
            f.write_str("Properties(")?;
            core::fmt::Debug::fmt(self, f)?;
            f.write_str(" (0x")?;
            core::fmt::LowerHex::fmt(&self.bits, f)?;
            f.write_str("))")?;
            Ok(())
        }
    }

    /// Auxiliary data associated with the wasm exports.
    ///
    /// This is required to be stored within the data of a
    /// `Store<T>` itself so lifting/lowering state can be managed
    /// when translating between the host and wasm.
    #[derive(Default)]
    pub struct BitflagsData<'rt> {}
    pub struct Bitflags<T> {
        get_state: Box<dyn Fn(&mut T) -> &mut BitflagsData + Send + Sync>,
        get_properties: wit_bindgen_wasm3::rt::wasm3::Function<'rt, (), (i32,)>,
    }
    impl<T> Bitflags<T> {
        #[allow(unused_variables)]

        /// Adds any intrinsics, if necessary for this exported wasm
        /// functionality to the `linker` provided.
        ///
        /// The `get_state` closure is required to access the
        /// auxiliary data necessary for these wasm exports from
        /// the general store's state.
        pub fn add_to_linker(
            linker: &mut wasmtime::Linker<T>,
            get_state: impl Fn(&mut T) -> &mut BitflagsData + Send + Sync + Copy + 'static,
        ) -> anyhow::Result<()> {
            Ok(())
        }

        /// Instantiates the provided `module` using the specified
        /// parameters, wrapping up the result in a structure that
        /// translates between wasm and the host.
        ///
        /// The `linker` provided will have intrinsics added to it
        /// automatically, so it's not necessary to call
        /// `add_to_linker` beforehand. This function will
        /// instantiate the `module` otherwise using `linker`, and
        /// both an instance of this structure and the underlying
        /// `wasmtime::Instance` will be returned.
        ///
        /// The `get_state` parameter is used to access the
        /// auxiliary state necessary for these wasm exports from
        /// the general store state `T`.
        pub fn instantiate(
            mut store: impl wasmtime::AsContextMut<Data = T>,
            module: &wasmtime::Module,
            linker: &mut wasmtime::Linker<T>,
            get_state: impl Fn(&mut T) -> &mut BitflagsData + Send + Sync + Copy + 'static,
        ) -> anyhow::Result<(Self, wasmtime::Instance)> {
            Self::add_to_linker(linker, get_state)?;
            let instance = linker.instantiate(&mut store, module)?;
            Ok((Self::new(store, &instance, get_state)?, instance))
        }

        /// Low-level creation wrapper for wrapping up the exports
        /// of the `instance` provided in this structure of wasm
        /// exports.
        ///
        /// This function will extract exports from the `instance`
        /// defined within `store` and wrap them all up in the
        /// returned structure which can be used to interact with
        /// the wasm module.
        pub fn new(
            mut store: impl wasmtime::AsContextMut<Data = T>,
            instance: &wasmtime::Instance,
            get_state: impl Fn(&mut T) -> &mut BitflagsData + Send + Sync + Copy + 'static,
        ) -> anyhow::Result<Self> {
            let mut store = store.as_context_mut();
            let get_properties =
                instance.get_typed_func::<(), (i32,), _>(&mut store, "get-properties")?;
            Ok(Bitflags {
                get_properties,
                get_state: Box::new(get_state),
            })
        }
        pub fn get_properties(
            &self,
            mut caller: wit_bindgen_wasm3::rt::wasm3::Runtime<'_>,
        ) -> Result<Properties, wit_bindgen_wasm3::rt::wasm3::error::Trap> {
            let (result0_0,) = self.get_properties.call(&mut caller, ())?;
            Ok(validate_flags(
                0 | (i64::from(result0_0) << 0),
                Properties::all().bits() as i64,
                "Properties",
                |b| Properties { bits: b as u8 },
            )?)
        }
    }
    use wit_bindgen_wasm3::rt::validate_flags;
}

